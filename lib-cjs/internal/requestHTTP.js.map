{"version":3,"sources":["../../lib/internal/requestHTTP.js"],"names":["ERROR_EVENT","REDIRECT_EVENT","RESPONSE_EVENT","createRequest","url","auth","method","options","retry","Promise","resolve","reject","headers","userAgent","cookie","redirects","agent","proxyHeaders","stringifyAuth","rejectUnauthorized","retries","throwHttpErrors","on","stream","push","simplifyResponse","response","HEAD_METHOD","retryHeadFail","retryHeadCodes","includes","status","GET_METHOD","statusCode","statusMessage","statusText","URL","password","username","cache","isURL","lenient","TypeError","BLC_INVALID","promise","toLowerCase","cacheResponses","cachedPromise","then","set","forEach","redirect","i","subsequentRedirects","slice","catch","error"],"mappings":"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","sourcesContent":["import {BLC_INVALID} from \"./reasons\";\nimport {GET_METHOD, HEAD_METHOD} from \"./methods\";\nimport isURL from \"isurl\";\nimport {stream as streamHTTP} from \"got\";\nimport tunnel from \"auto-tunnel\";\n\n\n\nconst ERROR_EVENT = \"error\";\nconst REDIRECT_EVENT = \"redirect\";\nconst RESPONSE_EVENT = \"response\";\n\n\n\n/**\n * Create an HTTP request.\n * @param {URL} url\n * @param {object} auth\n * @param {string} method\n * @param {object} options\n * @param {boolean} [retry]\n * @returns {Promise<object>}\n */\nconst createRequest = (url, auth, method, options, retry=false) => new Promise((resolve, reject) =>\n{\n\tconst headers = { \"user-agent\":options.userAgent, \"cookie\":options.cookie };\n\tconst redirects = [];\n\n\tstreamHTTP(url,\n\t{\n\t\tagent: tunnel(url, { proxyHeaders:headers }),\n\t\tauth: stringifyAuth(url, auth),\n\t\theaders,\n\t\tmethod,\n\t\trejectUnauthorized: false,  // accept self-signed SSL certificates\n\t\tretries: 0,  // explicit; they're already disabled for streams\n\t\tthrowHttpErrors: false\n\t})\n\t.on(ERROR_EVENT, reject)\n\t.on(REDIRECT_EVENT, stream => redirects.push( simplifyResponse(stream) ))\n\t.on(RESPONSE_EVENT, stream =>\n\t{\n\t\tconst response = simplifyResponse(stream, redirects);\n\n\t\tif (!retry && method===HEAD_METHOD && options.retryHeadFail && options.retryHeadCodes.includes(response.status))\n\t\t{\n\t\t\t// Retry potentially broken server with GET_METHOD\n\t\t\tresolve( createRequest(url, auth, GET_METHOD, options, true) );\n\t\t}\n\t\telse if (method===GET_METHOD && response.status>=200 && response.status<=299)\n\t\t{\n\t\t\tresolve({ response, stream });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresolve({ response });\n\t\t}\n\t});\n});\n\n\n\n/**\n * Create a simple response object from that of the \"http\" module.\n * @param {object|Stream} response\n * @param {Array<object>} [redirects]\n * @returns {object}\n * @todo add response time -- https://github.com/sindresorhus/got/issues/874\n */\nconst simplifyResponse = ({headers, statusCode, statusMessage, url}, redirects) =>\n({\n\theaders,\n\tstatus: statusCode,\n\tstatusText: statusMessage,\n\turl: new URL(url),\n\t...(redirects && {redirects})\n});\n\n\n\n/**\n * Convert an HTTP authentication URL or object into a string.\n * @param {URL} url\n * @param {object} auth\n * @returns {string}\n */\nconst stringifyAuth = (url, auth) =>\n{\n\tif (url.password!==\"\" || url.username!==\"\")\n\t{\n\t\treturn `${url.username}:${url.password}`;\n\t}\n\telse if (auth.password!==\"\" || auth.username!==\"\")\n\t{\n\t\treturn `${auth.username}:${auth.password}`;\n\t}\n};\n\n\n\n/**\n * Create an HTTP request and optionally cache the response.\n * @param {URL} url\n * @param {object} auth\n * @param {string} method\n * @param {URLCache} cache\n * @param {object} options\n * @throws {TypeError} non-URL\n * @returns {Promise<object>}\n * @todo use `Promise.try()` instead of `async`\n */\nexport default async (url, auth, method, cache, options) =>\n{\n\tif (!isURL.lenient(url))\n\t{\n\t\tthrow new TypeError(BLC_INVALID);\n\t}\n\telse\n\t{\n\t\tconst promise = createRequest(url, auth, method.toLowerCase(), options);\n\n\t\tif (options.cacheResponses)\n\t\t{\n\t\t\tconst cachedPromise = promise\n\t\t\t.then(({response}) =>\n\t\t\t{\n\t\t\t\t// Replace cached promise\n\t\t\t\t// @todo store in a \"response\" key, so that we can also store a list of all element IDs in the document\n\t\t\t\tcache.set(url, response);\n\n\t\t\t\t// Any final redirect\n\t\t\t\t// @todo store in a \"response\" key, so that we can also store a list of all element IDs in the document\n\t\t\t\tcache.set(response.url, response);\n\n\t\t\t\t// Any intermediary redirects\n\t\t\t\tresponse.redirects.forEach((redirect, i) =>\n\t\t\t\t{\n\t\t\t\t\tconst subsequentRedirects = response.redirects.slice(i + 1);\n\n\t\t\t\t\t// @todo store in a \"response\" key, so that we can also store a list of all element IDs in the document\n\t\t\t\t\tcache.set(redirect.url, {...response, redirects:subsequentRedirects});\n\t\t\t\t});\n\n\t\t\t\treturn response;\n\t\t\t})\n\t\t\t.catch(error => error);  // pass-through\n\n\t\t\t// Make future response available to other requests before completion\n\t\t\t// Will always overwrite previous value\n\t\t\t// @todo store in a \"response\" key, so that we can also store a list of all element IDs in the document\n\t\t\tcache.set(url, cachedPromise);\n\t\t}\n\n\t\treturn promise;\n\t}\n};\n"],"file":"requestHTTP.js"}